package config

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/flurbudurbur/Shiori/internal/domain"
	"github.com/flurbudurbur/Shiori/internal/logger" // Keep for the interface
	"github.com/r3labs/sse/v2"                       // For sse.Server type in mock
	"github.com/rs/zerolog"                          // For zerolog.Event and zerolog.Context
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Helper function to reset Viper for isolated tests
func resetViper() {
	viper.Reset()
}

// Ensure MockLogger satisfies logger.Logger.
var _ logger.Logger = (*MockLogger)(nil)

func TestNew(t *testing.T) {
	t.Run("should load defaults when no config path is provided and no file exists", func(t *testing.T) {
		resetViper()
		// This test assumes Viper won't find a config in default locations.
		// Behavior might vary if a config.toml exists in CWD or home dirs.

		cfgApp := New("", "test-v1")
		require.NotNil(t, cfgApp)
		require.NotNil(t, cfgApp.Config)

		// Expected defaults (before any file is written or read)
		expected := &domain.Config{}
		appCfgForDefaults := &AppConfig{}
		appCfgForDefaults.defaults() // Use the actual defaults method to get expected values
		expected = appCfgForDefaults.Config

		expected.Version = "test-v1" // Overridden by New()
		expected.ConfigPath = ""      // Overridden by New()
		// When configPath is "", load treats it as ".", writeConfig runs,
		// creating config.toml in CWD. So logging path will be "log/" from template.
		expected.Logging.Path = "log/"


		assert.Equal(t, expected.Version, cfgApp.Config.Version)
		assert.Equal(t, expected.ConfigPath, cfgApp.Config.ConfigPath)
		assert.Equal(t, expected.CheckForUpdates, cfgApp.Config.CheckForUpdates)

		// SessionSecret will be generated by writeConfig and loaded.
		assert.NotEmpty(t, cfgApp.Config.SessionSecret, "SessionSecret should be generated and not empty")
		assert.NotEqual(t, "secret-session-key", cfgApp.Config.SessionSecret, "SessionSecret should be a new generated value")

		assert.Equal(t, expected.Server, cfgApp.Config.Server)
		assert.Equal(t, expected.Database, cfgApp.Config.Database)
		assert.Equal(t, expected.Logging, cfgApp.Config.Logging)
		assert.Equal(t, expected.Valkey, cfgApp.Config.Valkey)
		assert.Equal(t, expected.RateLimit, cfgApp.Config.RateLimit)
		assert.Equal(t, expected.UUIDCleanup, cfgApp.Config.UUIDCleanup)
	})

	t.Run("should create and load config when config path is provided and no file exists", func(t *testing.T) {
		resetViper()
		tmpDir, err := os.MkdirTemp("", "config_test_create_")
		require.NoError(t, err)
		defer os.RemoveAll(tmpDir)

		cfgApp := New(tmpDir, "test-v2")
		require.NotNil(t, cfgApp)
		require.NotNil(t, cfgApp.Config)

		assert.Equal(t, "test-v2", cfgApp.Config.Version)
		assert.Equal(t, tmpDir, cfgApp.Config.ConfigPath)

		configFile := filepath.Join(tmpDir, "config.toml")
		_, err = os.Stat(configFile)
		require.NoError(t, err, "config.toml should be created")

		content, err := os.ReadFile(configFile)
		require.NoError(t, err)
		contentStr := string(content)

		assert.Contains(t, contentStr, "session_secret = \"")
		assert.NotContains(t, contentStr, "{{ .sessionSecret }}")
		assert.NotContains(t, contentStr, "fallback-please-replace-this-secret-immediately")
		assert.NotEmpty(t, cfgApp.Config.SessionSecret)
		assert.NotEqual(t, "secret-session-key", cfgApp.Config.SessionSecret, "A new session secret should be loaded")

		// Determine expected host based on environment (simplified check)
		expectedHostInFile := "127.0.0.1" // Default if not Docker/LXC
		// This check is a simplification of the one in writeConfig.
		// A full test of that logic is complex for a unit test.
		if _, dockerErr := os.Stat("/.dockerenv"); dockerErr == nil {
			expectedHostInFile = "0.0.0.0"
		}
		assert.Contains(t, contentStr, "host = \""+expectedHostInFile+"\"")
		assert.Equal(t, expectedHostInFile, cfgApp.Config.Server.Host)

		assert.Equal(t, 8282, cfgApp.Config.Server.Port)     // Default from template
		assert.Equal(t, "sqlite", cfgApp.Config.Database.Type) // Default from template
		assert.Equal(t, "log/", cfgApp.Config.Logging.Path)   // Default from template
		assert.Equal(t, "DEBUG", cfgApp.Config.Logging.Level) // Default from template
	})

	t.Run("should load existing config file with custom values", func(t *testing.T) {
		resetViper()
		tmpDir, err := os.MkdirTemp("", "config_test_custom_")
		require.NoError(t, err)
		defer os.RemoveAll(tmpDir)

		customConfigContent := `
check_for_updates = false
session_secret = "my-custom-secret"

[server]
  host = "192.168.1.100"
  port = 9090
  base_url = "/shiori"

[database]
  type = "postgres"
  [database.postgres]
    host = "db.example.com"
    port = 5433
    database = "shioridb"
    user = "shioriuser"
    pass = "shioripass"
    ssl_mode = "require"

[logging]
  path = "/var/log/shiori/"
  level = "INFO"
  max_file_size = 100
  max_backup_count = 5

[valkey]
  address = "valkey.example.com:6380"
  password = "valkeypass"
  db = 1
  
[rate_limit]
  enabled = false
  requests_per_minute = 100
  window_seconds = 30
  exempt_roles = "admin,editor"
  exempt_internal_ips = "10.0.0.1"

[uuid_cleanup]
  enabled = false
  schedule = "0 0 * * *"
  inactivity_days = 90
  delete_orphaned_uuids = false
  use_soft_delete = true
`
  configFile := filepath.Join(tmpDir, "config.toml")
  // Trim whitespace to ensure clean TOML parsing
  err = os.WriteFile(configFile, []byte(strings.TrimSpace(customConfigContent)), 0644)
  require.NoError(t, err)

  cfgApp := New(tmpDir, "test-v3")
		require.NotNil(t, cfgApp)
		require.NotNil(t, cfgApp.Config)

		assert.Equal(t, "test-v3", cfgApp.Config.Version)
		assert.Equal(t, tmpDir, cfgApp.Config.ConfigPath)

		assert.False(t, cfgApp.Config.CheckForUpdates)
		assert.Equal(t, "my-custom-secret", cfgApp.Config.SessionSecret)

		assert.Equal(t, "192.168.1.100", cfgApp.Config.Server.Host)
		assert.Equal(t, 9090, cfgApp.Config.Server.Port)
		assert.Equal(t, "/shiori", cfgApp.Config.Server.BaseURL)

		assert.Equal(t, "postgres", cfgApp.Config.Database.Type)
		assert.Equal(t, "db.example.com", cfgApp.Config.Database.Postgres.Host)
		assert.Equal(t, 5433, cfgApp.Config.Database.Postgres.Port)
		assert.Equal(t, "shioridb", cfgApp.Config.Database.Postgres.Database)
		assert.Equal(t, "shioriuser", cfgApp.Config.Database.Postgres.User)
		assert.Equal(t, "shioripass", cfgApp.Config.Database.Postgres.Pass)
		assert.Equal(t, "require", cfgApp.Config.Database.Postgres.SslMode)

		assert.Equal(t, "/var/log/shiori/", cfgApp.Config.Logging.Path)
		assert.Equal(t, "INFO", cfgApp.Config.Logging.Level)
		assert.Equal(t, 100, cfgApp.Config.Logging.MaxFileSize)
		assert.Equal(t, 5, cfgApp.Config.Logging.MaxBackupCount)

		assert.Equal(t, "valkey.example.com:6380", cfgApp.Config.Valkey.Address)
		assert.Equal(t, "valkeypass", cfgApp.Config.Valkey.Password)
		assert.Equal(t, 1, cfgApp.Config.Valkey.DB)
		
		assert.False(t, cfgApp.Config.RateLimit.Enabled)
		assert.Equal(t, 100, cfgApp.Config.RateLimit.RequestsPerMinute)
		assert.Equal(t, 30, cfgApp.Config.RateLimit.WindowSeconds)
		assert.Equal(t, "admin,editor", cfgApp.Config.RateLimit.ExemptRoles)
		assert.Equal(t, "10.0.0.1", cfgApp.Config.RateLimit.ExemptInternalIPs)

		assert.False(t, cfgApp.Config.UUIDCleanup.Enabled)
		assert.Equal(t, "0 0 * * *", cfgApp.Config.UUIDCleanup.Schedule)
		assert.Equal(t, 90, cfgApp.Config.UUIDCleanup.InactivityDays)
		assert.False(t, cfgApp.Config.UUIDCleanup.DeleteOrphanedUUIDs)
		assert.True(t, cfgApp.Config.UUIDCleanup.UseSoftDelete)
	})

	t.Run("should handle fatal error on unmarshal failure", func(t *testing.T) {
		resetViper()
		// This test is skipped because log.Fatalf calls os.Exit(1),
		// which terminates the test runner. Proper testing requires
		// refactoring log.Fatalf or running in a separate process.
		t.Skip("Skipping test for log.Fatalf on unmarshal error due to os.Exit behavior.")

		// Example of how it might be structured if log.Fatalf could be handled:
		// tmpDir, err := os.MkdirTemp("", "config_test_unmarshal_fail_")
		// require.NoError(t, err)
		// defer os.RemoveAll(tmpDir)
		// malformedConfigContent := `[server]\n  port = "not_an_int"`
		// configFile := filepath.Join(tmpDir, "config.toml")
		// err = os.WriteFile(configFile, []byte(malformedConfigContent), 0644)
		// require.NoError(t, err)
		// assert.PanicsWithValue(t, "expected panic or exit", func() { New(tmpDir, "test-v4") })
	})
}

// capturingWriter implements io.Writer to capture log messages.
type capturingWriter struct {
	storage *[]string
}

func (cw *capturingWriter) Write(p []byte) (n int, err error) {
	*cw.storage = append(*cw.storage, strings.TrimSpace(string(p)))
	return len(p), nil
}

// MockLogger for DynamicReload tests
type MockLogger struct {
	levelSet      string
	infoMsgs      []string
	errorMsgs     []string
	debugMsgs     []string
	warnMsgs      []string
	fatalMsgs     []string
	traceMsgs     []string
	logMsgs       []string

	// Internal zerolog.Logger instances
	infoLogger  zerolog.Logger
	errorLogger zerolog.Logger
	debugLogger zerolog.Logger
	warnLogger  zerolog.Logger
	fatalLogger zerolog.Logger
	traceLogger zerolog.Logger
	logLogger   zerolog.Logger

	registeredSSE bool
}

func NewMockLogger() *MockLogger {
	m := &MockLogger{
		infoMsgs:  make([]string, 0),
		errorMsgs: make([]string, 0),
		debugMsgs: make([]string, 0),
		warnMsgs:  make([]string, 0),
		fatalMsgs: make([]string, 0),
		traceMsgs: make([]string, 0),
		logMsgs:   make([]string, 0),
	}

	// Configure zerolog to output plain text for easier assertion
	// Note: By default, zerolog outputs JSON. For tests, sometimes plain text is easier.
	// However, to keep it simple and aligned with default zerolog behavior,
	// we'll capture the raw output (which will be JSON lines).
	// Assertions will use strings.Contains on these JSON lines.

	m.infoLogger = zerolog.New(&capturingWriter{storage: &m.infoMsgs})
	m.errorLogger = zerolog.New(&capturingWriter{storage: &m.errorMsgs})
	m.debugLogger = zerolog.New(&capturingWriter{storage: &m.debugMsgs})
	m.warnLogger = zerolog.New(&capturingWriter{storage: &m.warnMsgs})
	m.fatalLogger = zerolog.New(&capturingWriter{storage: &m.fatalMsgs}) // Real fatal would exit
	m.traceLogger = zerolog.New(&capturingWriter{storage: &m.traceMsgs})
	m.logLogger = zerolog.New(&capturingWriter{storage: &m.logMsgs})

	return m
}

// Implement logger.Logger interface for MockLogger
func (m *MockLogger) Log() *zerolog.Event   { return m.logLogger.Log() }
func (m *MockLogger) Fatal() *zerolog.Event { return m.fatalLogger.Fatal() } // Note: Real fatal exits
func (m *MockLogger) Err(err error) *zerolog.Event { return m.errorLogger.Error().Err(err) } // Standard way to log an error with Error level
func (m *MockLogger) Error() *zerolog.Event { return m.errorLogger.Error() }
func (m *MockLogger) Warn() *zerolog.Event  { return m.warnLogger.Warn() }
func (m *MockLogger) Info() *zerolog.Event  { return m.infoLogger.Info() }
func (m *MockLogger) Trace() *zerolog.Event { return m.traceLogger.Trace() }
func (m *MockLogger) Debug() *zerolog.Event { return m.debugLogger.Debug() }

func (m *MockLogger) With() zerolog.Context {
	// Return a Nop context or a context from one of the loggers if specific fields need to be tested.
	// For current config tests, Nop should be fine as With() is not used by DynamicReload.
	return zerolog.Nop().With()
}

func (m *MockLogger) RegisterSSEWriter(sseServer *sse.Server) { m.registeredSSE = true }
func (m *MockLogger) SetLogLevel(level string)                { m.levelSet = level }

// GetLogLevel is a helper for test assertions (not part of logger.Logger interface)
func (m *MockLogger) GetLogLevel() string { return m.levelSet }

func TestAppConfig_DynamicReload(t *testing.T) {
	resetViper() // Ensure Viper is clean for this test suite
	tmpDir, err := os.MkdirTemp("", "config_reload_test_")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	initialConfigContent := `
[server]
  port = 8080
[logging]
  level = "INFO"
`
	configFile := filepath.Join(tmpDir, "config.toml")
	err = os.WriteFile(configFile, []byte(initialConfigContent), 0644)
	require.NoError(t, err)

	cfgApp := New(tmpDir, "reload-test")
	require.NotNil(t, cfgApp)
	assert.Equal(t, 8080, cfgApp.Config.Server.Port)
	assert.Equal(t, "INFO", cfgApp.Config.Logging.Level)

	mockLog := NewMockLogger()
	cfgApp.DynamicReload(mockLog)

	// Modify the config file for successful reload
	updatedConfigContent := `
[server]
  port = 9090
[logging]
  level = "DEBUG"
`
	time.Sleep(100 * time.Millisecond) // Give watcher a moment to attach
	err = os.WriteFile(configFile, []byte(updatedConfigContent), 0644)
	require.NoError(t, err)
	time.Sleep(500 * time.Millisecond) // Allow time for fsnotify and reload

	assert.Equal(t, 9090, cfgApp.Config.Server.Port, "Server port should be updated")
	assert.Equal(t, "DEBUG", cfgApp.Config.Logging.Level, "Logging level should be updated")
	assert.Equal(t, "DEBUG", mockLog.levelSet, "Logger's SetLogLevel should be called")

	var foundReloadMsg, foundSuccessMsg bool
	// Check infoMsgs for "Config file changed" - it will be a JSON string
	// Use filepath.Base to avoid issues with path separators or JSON escaping of full path
	expectedLogFileReference := filepath.Base(configFile)
	for _, jsonLogLine := range mockLog.infoMsgs {
		if strings.Contains(jsonLogLine, "Config file changed") && strings.Contains(jsonLogLine, expectedLogFileReference) {
			foundReloadMsg = true
			break
		}
	}
	// Check debugMsgs for "Configuration reloaded successfully!"
	for _, jsonLogLine := range mockLog.debugMsgs {
		if strings.Contains(jsonLogLine, "Configuration reloaded successfully!") {
			foundSuccessMsg = true
			break
		}
	}
	assert.True(t, foundReloadMsg, "Expected log message about config change. Got: %v", mockLog.infoMsgs)
	assert.True(t, foundSuccessMsg, "Expected log message about successful reload. Got: %v", mockLog.debugMsgs)

	// Reset mock log messages for next part of test
	mockLog.infoMsgs = make([]string, 0) // Re-slice to clear
	mockLog.errorMsgs = make([]string, 0)
	mockLog.debugMsgs = make([]string, 0)


	// Modify with malformed config
	malformedConfigContent := `
[server]
  port = "not-an-integer" # This will cause unmarshal error
`
	time.Sleep(100 * time.Millisecond)
	err = os.WriteFile(configFile, []byte(malformedConfigContent), 0644)
	require.NoError(t, err)
	time.Sleep(500 * time.Millisecond)

	// Config should not have changed from the last valid one (9090, DEBUG)
	assert.Equal(t, 9090, cfgApp.Config.Server.Port, "Server port should remain after failed reload")
	assert.Equal(t, "DEBUG", cfgApp.Config.Logging.Level, "Logging level should remain after failed reload")
	// mockLog.levelSet should still be "DEBUG" as SetLogLevel is called with current c.Config.Logging.Level
	assert.Equal(t, "DEBUG", mockLog.levelSet, "Logger's level should not change if config is not updated")


	var foundErrorMsg bool
	// Check errorMsgs for "Error unmarshalling config" or "Error reading config file"
	for _, jsonLogLine := range mockLog.errorMsgs {
		if strings.Contains(jsonLogLine, "Error unmarshalling config") || strings.Contains(jsonLogLine, "Error reading config file") {
			foundErrorMsg = true
			break
		}
	}
	assert.True(t, foundErrorMsg, "Expected log message about error during reload. Got: %v", mockLog.errorMsgs)
}